<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Class blpapi::Session</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="bdedox.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>


  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="components.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespaceblpapi.html">blpapi</a>      </li>
      <li><a class="el" href="classblpapi_1_1Session.html">blpapi::Session</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>blpapi::Session Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="blpapi::Session" --><!-- doxytag: inherits="blpapi::AbstractSession" -->
<p><code>#include &lt;<a class="el" href="blpapi__session_8h_source.html">blpapi_session.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for blpapi::Session:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classblpapi_1_1Session.png" usemap="#blpapi::Session_map" alt=""/>
  <map id="blpapi::Session_map" name="blpapi::Session_map">
<area href="classblpapi_1_1AbstractSession.html" alt="blpapi::AbstractSession" shape="rect" coords="0,0,143,24"/>
</map>
</div>

<p><a href="classblpapi_1_1Session-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360">SubscriptionStatus</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec">UNSUBSCRIBED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_UNSUBSCRIBED, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f">SUBSCRIBING</a> =  BLPAPI_SUBSCRIPTIONSTATUS_SUBSCRIBING, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b">SUBSCRIBED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_SUBSCRIBED, 
<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5">CANCELLED</a> =  BLPAPI_SUBSCRIPTIONSTATUS_CANCELLED, 
<br/>
&nbsp;&nbsp;<a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a">PENDING_CANCELLATION</a> =  BLPAPI_SUBSCRIPTIONSTATUS_PENDING_CANCELLATION
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
::BloombergLP::blpapi::EventHandler&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a6fc289f05fab7e5abb4e0af45af0bf08">EventHandler</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ad311ac8efcc76c198eb8d4300b344a67">Session</a> (const <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> &amp;options=<a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a>(), <a class="el" href="classblpapi_1_1Session.html#a6fc289f05fab7e5abb4e0af45af0bf08">EventHandler</a> *eventHandler=0, <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> *eventDispatcher=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a0d9bebc2fd146fc72bf9e6cc1c57025a">Session</a> (<a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a2386b4275f4f342f4081736ec1599af9">~Session</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a6f56c2d6bb2a8db31f3f988f94094375">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a3acd2cd31ed28ebc16493e3e3858c724">stopAsync</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent</a> (int timeout=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a8e3d03c818e237df36c1e80cdbdefef4">tryNextEvent</a> (<a class="el" href="classblpapi_1_1Event.html">Event</a> *event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a1b3f1bc9013765ffcbddf265abae9fd3">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#acc15a1cbe1588ebdcfdaa5f583320599">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#add20e26c3eb8ebe4dc822d14c2d1d0ad">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#aa3c872790a718a29906a6b95772ebd71">subscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a1063f07253bc6f718b6c6d71b3dc8561">unsubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptionList)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#afab3a5134a19458d6f00a4d1a6db2c1a">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a4400b756f685aeb5420c2780ca3462e8">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#abfb128a594031504882300293b1b7d2b">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, const char *requestLabel, int requestLabelLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a932a9d83cb40ec4ee122105db706fa39">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, const char *requestLabel, int requestLabelLen, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a874ba2cd35ba8bcb17aa0a211f96bd31">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a44741b6c20a1250adb8f1dfbff544bc1">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#ad13db1165c96b3e78c4c243d2e65831f">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a727074e6f4f1dd4687f9c6f649dbfb75">resubscribe</a> (const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen, <a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a9b6464d4e2e61fc41c6c615cf9a66c84">setStatusCorrelationId</a> (const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;service, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a5f2c2031aa5db572b37a0c1c6bd5cd8d">setStatusCorrelationId</a> (const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;service, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a908f64e78691885190107c39fcfbd8cc">sendRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;request, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a3436c6d58a948da9a0a433e953983cef">sendRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;request, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;user, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a1160a8e8beefc1bd13ec1bfa4476bf14">sendRequest</a> (const <a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a> &amp;requestTemplate, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a2fd6d619ecfcbf257e65f468802a2939">createSnapshotRequestTemplate</a> (const char *subscriptionString, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;statusCid, const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;identity=<a class="el" href="classblpapi_1_1Identity.html">Identity</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a12963467436094660d332dcf22a4b655">handle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a82db9318887202671d158dbc50207cd6">openService</a> (const char *serviceIdentifier)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a25d1cb8d634d5314c02de8ce7da7b79a">openServiceAsync</a> (const char *serviceIdentifier, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6db5e2c5643b2b8f0137599585241c4d">sendAuthorizationRequest</a> (const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;authorizationRequest, <a class="el" href="classblpapi_1_1Identity.html">Identity</a> *identity, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a6351bdef344799c0909cbddede452750">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a9aa9a680b64ef2907bb5f5958eb986fe">cancel</a> (const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;correlationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a95c8f4f52942c298d8238ee798c9ca9b">cancel</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *correlationIds, size_t numCorrelationIds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a7959440c6429554e20dd284e8bc85cc1">generateToken</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a42fee00f84565962540cc803ac7aa741">generateToken</a> (const char *userId, const char *ipAddress, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>(), <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *eventQueue=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1Service.html">Service</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ac459514f50ddd209be5124d416dd10fe">getService</a> (const char *serviceIdentifier) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#ac5d7a27d3ffff9c218a3e02764ee0a86">createUserHandle</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classblpapi_1_1Identity.html">Identity</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a3632ffe2a37cccb5ade648a586b55b9d">createIdentity</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a4d7609c1f21e0fea8a7f5af9d7e84f89">generateAuthorizedIdentity</a> (const <a class="el" href="classblpapi_1_1AuthOptions.html">AuthOptions</a> &amp;authOptions, const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;cid=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classblpapi_1_1Identity.html">Identity</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#aff20f584012fd465b1839397500954e5">getAuthorizedIdentity</a> (const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;correlationId=<a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#aced40ce5767d5e2d7cb18688a790378e">abstractSessionHandle</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1AbstractSession.html#a72fbfd14bd1e06ee4a041385923d20f6">initAbstractSessionHandle</a> (<a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *handle)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classblpapi_1_1Session.html#a931ba54e37e62f7ee1f6eb96ad62b020">blpapi_eventHandlerAdapter</a> (<a class="el" href="group__blpapi__types.html#ga30bfd6b43ae20d0c8b1baf6f700450c6">blpapi_Event_t</a> *event, <a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *, void *userData)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a consumer session for making requests for Bloomberg services.</p>
<p>Sessions manage access to services either by requests and responses or subscriptions. A <a class="el" href="classblpapi_1_1Session.html">Session</a> can dispatch events and replies in either a synchronous or asynchronous mode. The mode of a <a class="el" href="classblpapi_1_1Session.html">Session</a> is determined when it is constructed and cannot be changed subsequently.</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is asynchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is supplied when it is constructed. All incoming events are delivered to the <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> supplied on construction. Calls to <code>nextEvent</code> on an asynchronous session will fail.</p>
<p>A <a class="el" href="classblpapi_1_1Session.html">Session</a> is synchronous if an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> object is not supplied when it is constructed. The <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> method must be called to read incoming events.</p>
<p>Several methods in <a class="el" href="classblpapi_1_1Session.html">Session</a> take a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> parameter. The application may choose to supply its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values or allow the <a class="el" href="classblpapi_1_1Session.html">Session</a> to create values. If the application supplies its own <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> values it must manage their lifetime such that the same value is not reused for more than one operation at a time. The lifetime of a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> begins when it is supplied in a method invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> and ends either when it is explicitly cancelled using <a class="el" href="classblpapi_1_1AbstractSession.html#a6351bdef344799c0909cbddede452750">cancel()</a> or <a class="el" href="classblpapi_1_1Session.html#a1063f07253bc6f718b6c6d71b3dc8561">unsubscribe()</a>, when a RESPONSE <a class="el" href="classblpapi_1_1Event.html">Event</a> (not a PARTIAL_RESPONSE) containing it is received or when a SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which indicates that the subscription it refers to has been terminated is received.</p>
<p>When using an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> the application must be aware that because the callbacks are generated from another thread they may be processed before the call which generates them has returned. For example, the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> generated by a <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> may be processed before <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> has returned (even though <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> itself will not block).</p>
<p>This becomes more significant when <a class="el" href="classblpapi_1_1Session.html">Session</a> generated CorrelationIds are in use. For example, if a call to <a class="el" href="classblpapi_1_1Session.html#a1b3f1bc9013765ffcbddf265abae9fd3">subscribe()</a> which returns a <a class="el" href="classblpapi_1_1Session.html">Session</a> generated <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> has not completed before the first Events which contain that <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> arrive the application may not be able to interpret those events correctly. For this reason, it is preferable to use user generated CorrelationIds when using asynchronous Sessions. This issue does not arise when using a synchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> as long as the calls to <a class="el" href="classblpapi_1_1Session.html#a1b3f1bc9013765ffcbddf265abae9fd3">subscribe()</a> etc. are made on the same thread as the calls to <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a>.</p>
<p>See <a class="el" href="group__blpapi__session.html">Component blpapi_session</a> </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a6fc289f05fab7e5abb4e0af45af0bf08"></a><!-- doxytag: member="blpapi::Session::EventHandler" ref="a6fc289f05fab7e5abb4e0af45af0bf08" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ::BloombergLP::blpapi::EventHandler <a class="el" href="classblpapi_1_1Session.html#a6fc289f05fab7e5abb4e0af45af0bf08">blpapi::Session::EventHandler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360"></a><!-- doxytag: member="blpapi::Session::SubscriptionStatus" ref="a5fe1734809ad256c4c45d5e2ef327360" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classblpapi_1_1Session.html#a5fe1734809ad256c4c45d5e2ef327360">blpapi::Session::SubscriptionStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec"></a><!-- doxytag: member="UNSUBSCRIBED" ref="a5fe1734809ad256c4c45d5e2ef327360a410f8e81450850ae6cecd92da3f18dec" args="" -->UNSUBSCRIBED</em>&nbsp;</td><td>
<p>No longer active, terminated by API. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f"></a><!-- doxytag: member="SUBSCRIBING" ref="a5fe1734809ad256c4c45d5e2ef327360a38b26d48c50b472f66893a93edf4c15f" args="" -->SUBSCRIBING</em>&nbsp;</td><td>
<p>Initiated but no updates received. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b"></a><!-- doxytag: member="SUBSCRIBED" ref="a5fe1734809ad256c4c45d5e2ef327360ac238df3a8ab8e98950aa4dc0a8f35b6b" args="" -->SUBSCRIBED</em>&nbsp;</td><td>
<p>Updates are flowing. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5"></a><!-- doxytag: member="CANCELLED" ref="a5fe1734809ad256c4c45d5e2ef327360a0abd1365c5cae7e3acdc713addce9cb5" args="" -->CANCELLED</em>&nbsp;</td><td>
<p>No longer active, terminated by Application. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a"></a><!-- doxytag: member="PENDING_CANCELLATION" ref="a5fe1734809ad256c4c45d5e2ef327360ab9d2fc78ba78271e982a3171e90b156a" args="" -->PENDING_CANCELLATION</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad311ac8efcc76c198eb8d4300b344a67"></a><!-- doxytag: member="blpapi::Session::Session" ref="ad311ac8efcc76c198eb8d4300b344a67" args="(const SessionOptions &amp;options=SessionOptions(), EventHandler *eventHandler=0, EventDispatcher *eventDispatcher=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">blpapi::Session::Session </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em> = <code><a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Session.html#a6fc289f05fab7e5abb4e0af45af0bf08">EventHandler</a> *&nbsp;</td>
          <td class="paramname"> <em>eventHandler</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> *&nbsp;</td>
          <td class="paramname"> <em>eventDispatcher</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <a class="el" href="classblpapi_1_1Session.html">Session</a> using the optionally specified <code>options</code>, the optionally specified <code>eventHandler</code> and the optionally specified <code>eventDispatcher</code>.</p>
<p>See the <a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a> documentation for details on what can be specified in the <code>options</code>.</p>
<p>If <code>eventHandler</code> is not null then this <a class="el" href="classblpapi_1_1Session.html">Session</a> will operation in asynchronous mode, otherwise the <a class="el" href="classblpapi_1_1Session.html">Session</a> will operate in synchronous mode.</p>
<p>If <code>eventDispatcher</code> is null then the <a class="el" href="classblpapi_1_1Session.html">Session</a> will create a default <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> for this <a class="el" href="classblpapi_1_1Session.html">Session</a> which will use a single thread for dispatching events. For more control over event dispatching a specific instance of <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> can be supplied. This can be used to share a single <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> amongst multiple <a class="el" href="classblpapi_1_1Session.html">Session</a> objects.</p>
<p>If an <code>eventDispatcher</code> is supplied which uses more than one thread the <a class="el" href="classblpapi_1_1Session.html">Session</a> will ensure that events which should be ordered are passed to callbacks in a correct order. For example, partial response to a request or updates to a single subscription.</p>
<p>The behavior is undefined if <code>eventHandler</code> is null and the <code>eventDispatcher</code> is not null.</p>
<p>Each <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a> uses its own thread or pool of threads so if you want to ensure that a session which receives very large messages and takes a long time to process them does not delay a session that receives small messages and processes each one very quickly then give each one a separate <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a>. </p>

</div>
</div>
<a class="anchor" id="a0d9bebc2fd146fc72bf9e6cc1c57025a"></a><!-- doxytag: member="blpapi::Session::Session" ref="a0d9bebc2fd146fc72bf9e6cc1c57025a" args="(blpapi_Session_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">blpapi::Session::Session </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2386b4275f4f342f4081736ec1599af9"></a><!-- doxytag: member="blpapi::Session::~Session" ref="a2386b4275f4f342f4081736ec1599af9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual blpapi::Session::~Session </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="adf5890d97c42d723a05324442e5dfbd2"></a><!-- doxytag: member="blpapi::Session::start" ref="adf5890d97c42d723a05324442e5dfbd2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::Session::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and block until the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or failed to start. If the <a class="el" href="classblpapi_1_1Session.html">Session</a> is started successfully <code>true</code> is returned, otherwise <code>false</code> is returned. Before <a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start()</a> returns a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1Session.html#adf5890d97c42d723a05324442e5dfbd2">start()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#ace4e657cd0a05ebed423e888f4ce943f">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a0f51151d1f1aecb4e3df1ab9494cb9a4"></a><!-- doxytag: member="blpapi::Session::startAsync" ref="a0f51151d1f1aecb4e3df1ab9494cb9a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::Session::startAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to begin the process to start this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return <code>true</code> if successful, otherwise return <code>false</code>. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has started or if it fails to start. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1Session.html#a0f51151d1f1aecb4e3df1ab9494cb9a4">startAsync()</a> has returned. A <a class="el" href="classblpapi_1_1Session.html">Session</a> may only be started once. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#ab2c59500373e25393dbfe20311361d9d">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a6f56c2d6bb2a8db31f3f988f94094375"></a><!-- doxytag: member="blpapi::Session::stop" ref="a6f56c2d6bb2a8db31f3f988f94094375" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop operation of this session and block until all callbacks to <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> objects relating to this <a class="el" href="classblpapi_1_1Session.html">Session</a> which are currently in progress have completed (including the callback to handle the SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message this call generates). Once this returns no further callbacks to EventHandlers will occur. If <a class="el" href="classblpapi_1_1Session.html#a6f56c2d6bb2a8db31f3f988f94094375">stop()</a> is called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback the behavior is undefined and may result in a deadlock. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#a969ca873556672770ca09295fe1a5870">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a3acd2cd31ed28ebc16493e3e3858c724"></a><!-- doxytag: member="blpapi::Session::stopAsync" ref="a3acd2cd31ed28ebc16493e3e3858c724" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::stopAsync </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to stop this <a class="el" href="classblpapi_1_1Session.html">Session</a> and return immediately. The application must monitor events for a SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> with SessionTerminated message which will be generated once the <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped. After this SESSION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> no further callbacks to EventHandlers will occur. This method can be called from within an <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> callback to stop Sessions using non-default (external) <a class="el" href="classblpapi_1_1EventDispatcher.html">EventDispatcher</a>. Once a <a class="el" href="classblpapi_1_1Session.html">Session</a> has been stopped it can only be destroyed. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#af45d8a8baaffaedba84142efead7dccb">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="ae4047ea10fb95b189847d5d67d73a027"></a><!-- doxytag: member="blpapi::Session::nextEvent" ref="ae4047ea10fb95b189847d5d67d73a027" args="(int timeout=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1Event.html">Event</a> blpapi::Session::nextEvent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the next available <a class="el" href="classblpapi_1_1Event.html">Event</a> for this session. If there is no event available this will block for up to the specified <code>timeoutMillis</code> milliseconds for an <a class="el" href="classblpapi_1_1Event.html">Event</a> to arrive. A value of 0 for <code>timeoutMillis</code> (the default) indicates <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> should not timeout and will not return until the next <a class="el" href="classblpapi_1_1Event.html">Event</a> is available.</p>
<p>If <a class="el" href="classblpapi_1_1Session.html#ae4047ea10fb95b189847d5d67d73a027">nextEvent()</a> returns due to a timeout it will return an event of type <code>EventType::TIMEOUT</code>.</p>
<p>If this is invoked on a <a class="el" href="classblpapi_1_1Session.html">Session</a> which was created in asynchronous mode an <a class="el" href="classblpapi_1_1InvalidStateException.html">InvalidStateException</a> is thrown. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#a6ad5b2d683b4b80b00134bd3d855fbe6">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a8e3d03c818e237df36c1e80cdbdefef4"></a><!-- doxytag: member="blpapi::Session::tryNextEvent" ref="a8e3d03c818e237df36c1e80cdbdefef4" args="(Event *event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int blpapi::Session::tryNextEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Event.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If there are Events available for the session, load the next <a class="el" href="classblpapi_1_1Event.html">Event</a> into event and return 0 indicating success. If there is no event available for the session, return a non-zero value with no effect on event. This method never blocks. </p>

<p>Implements <a class="el" href="classblpapi_1_1AbstractSession.html#af2b18809b8fd26cf3a943a3e433a1bcc">blpapi::AbstractSession</a>.</p>

</div>
</div>
<a class="anchor" id="a1b3f1bc9013765ffcbddf265abae9fd3"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="a1b3f1bc9013765ffcbddf265abae9fd3" args="(const SubscriptionList &amp;subscriptionList, const Identity &amp;identity, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the specified <code>identity</code> for authorization. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each entry in the <code>subscriptionList</code>. </p>

</div>
</div>
<a class="anchor" id="acc15a1cbe1588ebdcfdaa5f583320599"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="acc15a1cbe1588ebdcfdaa5f583320599" args="(const SubscriptionList &amp;subscriptionList, const Identity &amp;identity, SubscriptionPreprocessMode::Enum mode, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the specified <code>identity</code> for authorization.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes.</p>
<p>If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each valid subscriptions in the list. </p>

</div>
</div>
<a class="anchor" id="add20e26c3eb8ebe4dc822d14c2d1d0ad"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="add20e26c3eb8ebe4dc822d14c2d1d0ad" args="(const SubscriptionList &amp;subscriptionList, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the session identity information. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each entry in the <code>subscriptionList</code>.</p>
<p>The session identity will be used if it has been authorized. </p>

</div>
</div>
<a class="anchor" id="aa3c872790a718a29906a6b95772ebd71"></a><!-- doxytag: member="blpapi::Session::subscribe" ref="aa3c872790a718a29906a6b95772ebd71" args="(const SubscriptionList &amp;subscriptionList, SubscriptionPreprocessMode::Enum mode, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::subscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin subscriptions for each entry in the specified <code>subscriptionList</code> using the session identity information.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes.</p>
<p>If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A SUBSCRIPTION_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> will be generated for each entry in the <code>subscriptionList</code>.</p>
<p>The session identity will be used if it has been authorized. </p>

</div>
</div>
<a class="anchor" id="a1063f07253bc6f718b6c6d71b3dc8561"></a><!-- doxytag: member="blpapi::Session::unsubscribe" ref="a1063f07253bc6f718b6c6d71b3dc8561" args="(const SubscriptionList &amp;subscriptionList)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptionList</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel each of the current subscriptions identified by the specified <code>subscriptionList</code>. If the correlation ID of any entry in the <code>subscriptionList</code> does not identify a current subscription then that entry is ignored. All entries which have valid correlation IDs will be cancelled.</p>
<p>Once this call returns the correlation ids in the <code>subscriptionList</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1Session.html#a1063f07253bc6f718b6c6d71b3dc8561">unsubscribe()</a> is called is not affected even if it has one of the correlation IDs in the <code>subscriptionList</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain a correlation ID from the <code>subscriptionList</code>. For these reasons, although technically an application is free to re-use the correlation IDs as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="afab3a5134a19458d6f00a4d1a6db2c1a"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="afab3a5134a19458d6f00a4d1a6db2c1a" args="(const SubscriptionList &amp;subscriptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a4400b756f685aeb5420c2780ca3462e8"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a4400b756f685aeb5420c2780ca3462e8" args="(const SubscriptionList &amp;subscriptions, SubscriptionPreprocessMode::Enum mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes. </p>

</div>
</div>
<a class="anchor" id="abfb128a594031504882300293b1b7d2b"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="abfb128a594031504882300293b1b7d2b" args="(const SubscriptionList &amp;subscriptions, const char *requestLabel, int requestLabelLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a932a9d83cb40ec4ee122105db706fa39"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a932a9d83cb40ec4ee122105db706fa39" args="(const SubscriptionList &amp;subscriptions, const char *requestLabel, int requestLabelLen, SubscriptionPreprocessMode::Enum mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event will be generated in the event stream before the first update based on the new options.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes. </p>

</div>
</div>
<a class="anchor" id="a874ba2cd35ba8bcb17aa0a211f96bd31"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a874ba2cd35ba8bcb17aa0a211f96bd31" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a44741b6c20a1250adb8f1dfbff544bc1"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a44741b6c20a1250adb8f1dfbff544bc1" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId, SubscriptionPreprocessMode::Enum mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes. </p>

</div>
</div>
<a class="anchor" id="ad13db1165c96b3e78c4c243d2e65831f"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="ad13db1165c96b3e78c4c243d2e65831f" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options. If the correlation ID of an entry in the <code>subscriptionList</code> does not identify a current subscription then an exception is thrown. </p>

</div>
</div>
<a class="anchor" id="a727074e6f4f1dd4687f9c6f649dbfb75"></a><!-- doxytag: member="blpapi::Session::resubscribe" ref="a727074e6f4f1dd4687f9c6f649dbfb75" args="(const SubscriptionList &amp;subscriptions, int resubscriptionId, const char *requestLabel, int requestLabelLen, SubscriptionPreprocessMode::Enum mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceblpapi.html#a198fcb88f2def81730a61a7a58f18d57">SubscriptionPreprocessErrors</a> blpapi::Session::resubscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1SubscriptionList.html">SubscriptionList</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>subscriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>resubscriptionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html#ab575b3ee2ddca1d07e0a696fef435981">SubscriptionPreprocessMode::Enum</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify each subscription in the specified <code>subscriptionList</code> to reflect the modified options specified for it. The specified <code>requestLabel</code> and <code>requestLabelLen</code> define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>For each entry in the <code>subscriptionList</code> which has a correlation ID which identifies a current subscription the modified options replace the current options for the subscription and a SUBSCRIPTION_STATUS event containing the specified <code>resubscriptionId</code> will be generated in the event stream before the first update based on the new options.</p>
<p>The specified <code>mode</code> is used to determine how to preprocess subscriptions. Refer to <code><a class="el" href="structblpapi_1_1SubscriptionPreprocessMode.html">SubscriptionPreprocessMode</a></code> for an explanation of the available modes. </p>

</div>
</div>
<a class="anchor" id="a9b6464d4e2e61fc41c6c615cf9a66c84"></a><!-- doxytag: member="blpapi::Session::setStatusCorrelationId" ref="a9b6464d4e2e61fc41c6c615cf9a66c84" args="(const Service &amp;service, const CorrelationId &amp;correlationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::setStatusCorrelationId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f2c2031aa5db572b37a0c1c6bd5cd8d"></a><!-- doxytag: member="blpapi::Session::setStatusCorrelationId" ref="a5f2c2031aa5db572b37a0c1c6bd5cd8d" args="(const Service &amp;service, const Identity &amp;identity, const CorrelationId &amp;correlationID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::Session::setStatusCorrelationId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Service.html">Service</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>service</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationID</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the CorrelationID on which service status messages will be received. Note: No service status messages are received prior to this call </p>

</div>
</div>
<a class="anchor" id="a908f64e78691885190107c39fcfbd8cc"></a><!-- doxytag: member="blpapi::Session::sendRequest" ref="a908f64e78691885190107c39fcfbd8cc" args="(const Request &amp;request, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::Session::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>request</code>. If the optionally specified <code>correlationId</code> is supplied use it otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the correlation ID associated with this request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated after which the correlation ID associated with the request may be re-used.</p>
<p>The session identity will be used if it has been authorized. </p>

</div>
</div>
<a class="anchor" id="a3436c6d58a948da9a0a433e953983cef"></a><!-- doxytag: member="blpapi::Session::sendRequest" ref="a3436c6d58a948da9a0a433e953983cef" args="(const Request &amp;request, const Identity &amp;user, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0, const char *requestLabel=0, int requestLabelLen=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::Session::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>requestLabel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestLabelLen</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>request</code> using the specified <code>identity</code> for authorization. If the optionally specified <code>correlationId</code> is supplied use it otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>. If the optional <code>requestLabel</code> and <code>requestLabelLen</code> are provided they define a string which will be recorded along with any diagnostics for this operation. There must be at least <code>requestLabelLen</code> printable characters at the location <code>requestLabel</code>.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with this request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated after which the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with the request may be re-used. </p>

</div>
</div>
<a class="anchor" id="a1160a8e8beefc1bd13ec1bfa4476bf14"></a><!-- doxytag: member="blpapi::Session::sendRequest" ref="a1160a8e8beefc1bd13ec1bfa4476bf14" args="(const RequestTemplate &amp;requestTemplate, const CorrelationId &amp;correlationId=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::Session::sendRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>requestTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send a request defined by the specified <code>requestTemplate</code>. If the optionally specified <code>correlationId</code> is supplied, use it otherwise create a new <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a></code>. The actual <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a></code> used is returned.</p>
<p>A successful request will generate zero or more <code>PARTIAL_RESPONSE</code> events followed by exactly one <code>RESPONSE</code> event. Once the final <code>RESPONSE</code> event has been received the <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a></code> associated with this request may be re-used. If the request fails at any stage a <code>REQUEST_STATUS</code> will be generated after which the <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a></code> associated with the request may be re-used.</p>
<p>The session identity will be used if it has been authorized. </p>

</div>
</div>
<a class="anchor" id="a2fd6d619ecfcbf257e65f468802a2939"></a><!-- doxytag: member="blpapi::Session::createSnapshotRequestTemplate" ref="a2fd6d619ecfcbf257e65f468802a2939" args="(const char *subscriptionString, const CorrelationId &amp;statusCid, const Identity &amp;identity=Identity())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a> blpapi::Session::createSnapshotRequestTemplate </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subscriptionString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>statusCid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Identity.html">Identity</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>identity</em> = <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a snapshot request template for getting subscription data specified by the <code>subscriptionString</code> using the optionally specified <code>identity</code> if all the following conditions are met: the session is established, <code>subscriptionString</code> is a valid subscription string and <code>statusCid</code> is not used in this session. If one or more conditions are not met, an exception is thrown. The provided <code>statusCid</code> will be used for status updates about the created request template state and an implied subscription associated with it delivered by <code>SUBSCRIPTION_STATUS</code> events.</p>
<p>The benefit of the snapshot request templates is that these requests may be serviced from a cache and the user may expect to see significantly lower response time.</p>
<p>There are 3 possible states for a created request template: <code>Pending</code>, <code>Available</code>, and <code>Terminated</code>. Right after creation a request template is in the <code>Pending</code> state.</p>
<p>If a state is <code>Pending</code>, the user may send a request using this template but there are no guarantees about response time since cache is not available yet. <a class="el" href="classblpapi_1_1Request.html">Request</a> template may transition into <code>Pending</code> state only from the <code>Available</code> state. In this case the <code>RequestTemplatePending</code> message is generated.</p>
<p>If state is <code>Available</code>, all requests will be serviced from a cache and the user may expect to see significantly reduced latency. Note, that a snapshot request template can transition out of the <code>Available</code> state concurrently with requests being sent, so no guarantee of service from the cache can be provided. <a class="el" href="classblpapi_1_1Request.html">Request</a> template may transition into <code>Available</code> state only from the <code>Pending</code> state. In this case the <code>RequestTemplateAvailable</code> message is generated. This message will also contain information about currently used connection in the <code>boundTo</code> field. Note that it is possible to get the <code>RequestTemplateAvailable</code> message with a new connection information, even if a request template is already in the <code>Available</code> state.</p>
<p>If state is <code>Terminated</code>, sending request will always result in a failure response. <a class="el" href="classblpapi_1_1Request.html">Request</a> template may transition into this state from any other state. This is a final state and it is guaranteed that the last message associated with the provided <code>statusCid</code> will be the <code>RequestTemplateTerminated</code> message which is generated when a request template transitions into this state. If a request template transitions into this state, all outstanding requests will be failed and appropriate messages will be generated for each request. After receiving the <code>RequestTemplateTerminated</code> message, <code>statusCid</code> may be reused.</p>
<p>Note that resources used by a snapshot request template are released only when request template transitions into the <code>Terminated</code> state or when session is destroyed. In order to release resources when request template is not needed anymore, user should call the <code>Session::cancel(statusCid)</code> unless the <code>RequestTemplateTerminated</code> message was already received due to some problems. When the last copy of a <code><a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a></code> object goes out of scope and there are no outstanding requests left, the snapshot request template will be destroyed automatically. If the last copy of a <code><a class="el" href="classblpapi_1_1RequestTemplate.html">RequestTemplate</a></code> object goes out of scope while there are still some outstanding requests left, snapshot service request template will be destroyed automatically when the last request gets a final response.</p>
<p>Note that it is possible to have a situation when response contains data that were sent by a backend before user actually sends a request template. For example it is possible if user requested data were already in an incoming TCP queue.</p>
<p>If <code>identity</code> is not provided, the session identity will be used if it has been authorized. </p>

</div>
</div>
<a class="anchor" id="a12963467436094660d332dcf22a4b655"></a><!-- doxytag: member="blpapi::Session::handle" ref="a12963467436094660d332dcf22a4b655" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a>* blpapi::Session::handle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a72fbfd14bd1e06ee4a041385923d20f6"></a><!-- doxytag: member="blpapi::Session::initAbstractSessionHandle" ref="a72fbfd14bd1e06ee4a041385923d20f6" args="(blpapi_AbstractSession_t *handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi::AbstractSession::initAbstractSessionHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the handle of this abstract session. </p>

</div>
</div>
<a class="anchor" id="a82db9318887202671d158dbc50207cd6"></a><!-- doxytag: member="blpapi::Session::openService" ref="a82db9318887202671d158dbc50207cd6" args="(const char *serviceIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool blpapi::AbstractSession::openService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attempt to open the service identified by the specified <code>serviceIdentifier</code> and block until the service is either opened successfully or has failed to be opened. Return <code>true</code> if the service is opened successfully and <code>false</code> if the service cannot be successfully opened.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form <code>//&lt;namespace&gt;/&lt;local-name&gt;</code>.</p>
<p>Before <a class="el" href="classblpapi_1_1AbstractSession.html#a82db9318887202671d158dbc50207cd6">openService()</a> returns a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> is generated. If this is an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a> then this <a class="el" href="classblpapi_1_1Event.html">Event</a> may be processed by the registered <a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a> before <a class="el" href="classblpapi_1_1AbstractSession.html#a82db9318887202671d158dbc50207cd6">openService()</a> has returned. </p>

</div>
</div>
<a class="anchor" id="a25d1cb8d634d5314c02de8ce7da7b79a"></a><!-- doxytag: member="blpapi::Session::openServiceAsync" ref="a25d1cb8d634d5314c02de8ce7da7b79a" args="(const char *serviceIdentifier, const CorrelationId &amp;correlationId=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::openServiceAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the process to open the service identified by the specified <code>serviceIdentifier</code> and return immediately. The optional specified <code>correlationId</code> is used to track Events generated as a result of this call. The actual correlationId which will identify Events generated as a result of this call is returned.</p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form <code>//&lt;namespace&gt;/&lt;local-name&gt;</code>.</p>
<p>The application must monitor events for a SERVICE_STATUS <a class="el" href="classblpapi_1_1Event.html">Event</a> which will be generated once the service has been successfully opened or the opening has failed. </p>

</div>
</div>
<a class="anchor" id="a6db5e2c5643b2b8f0137599585241c4d"></a><!-- doxytag: member="blpapi::Session::sendAuthorizationRequest" ref="a6db5e2c5643b2b8f0137599585241c4d" args="(const Request &amp;authorizationRequest, Identity *identity, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::sendAuthorizationRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1Request.html">Request</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>authorizationRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> *&nbsp;</td>
          <td class="paramname"> <em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send the specified <code>authorizationRequest</code> and update the specified <code>identity</code> with the results. If the optionally specified <code>correlationId</code> is supplied, it is used; otherwise create a <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>. The actual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> used is returned. If the optionally specified <code>eventQueue</code> is supplied all Events relating to this <a class="el" href="classblpapi_1_1Request.html">Request</a> will arrive on that <a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a>.</p>
<p>The underlying user information must remain valid until the <a class="el" href="classblpapi_1_1Request.html">Request</a> has completed successfully or failed.</p>
<p>A successful request will generate zero or more PARTIAL_RESPONSE Messages followed by exactly one RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a>. Once the final RESPONSE <a class="el" href="classblpapi_1_1Message.html">Message</a> has been received the specified <code>identity</code> will have been updated to contain the users entitlement information and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> associated with the request may be re-used. If the request fails at any stage a REQUEST_STATUS will be generated, the specified <code>identity</code> will not be modified and the <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> may be re-used.</p>
<p>The <code>identity</code> supplied must have been returned from this Session's <code><a class="el" href="classblpapi_1_1AbstractSession.html#a3632ffe2a37cccb5ade648a586b55b9d">createIdentity()</a></code> method. For example </p>
<div class="fragment"><pre class="fragment">     Identity handle(session.<a class="code" href="classblpapi_1_1AbstractSession.html#a3632ffe2a37cccb5ade648a586b55b9d">createIdentity</a>());
     session.<a class="code" href="classblpapi_1_1AbstractSession.html#a6db5e2c5643b2b8f0137599585241c4d">sendAuthorizationRequest</a>(authRequest, &amp;handle, ...)
</pre></div> 
</div>
</div>
<a class="anchor" id="a6351bdef344799c0909cbddede452750"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a6351bdef344799c0909cbddede452750" args="(const CorrelationId &amp;correlationId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the specified <code>correlationId</code> identifies a current request then cancel that request.</p>
<p>Once this call returns the specified <code>correlationId</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a6351bdef344799c0909cbddede452750">cancel()</a> is called is not affected even if it has the specified <code>correlationId</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain the <code>correlationId</code>. For these reasons, although technically an application is free to re-use <code>correlationId</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a9aa9a680b64ef2907bb5f5958eb986fe"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a9aa9a680b64ef2907bb5f5958eb986fe" args="(const std::vector&lt; CorrelationId &gt; &amp;correlationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value in the specified <code>correlationIds</code> which identifies a current request then cancel that request. Any values in the specified <code>correlationIds</code> which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a6351bdef344799c0909cbddede452750">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a95c8f4f52942c298d8238ee798c9ca9b"></a><!-- doxytag: member="blpapi::Session::cancel" ref="a95c8f4f52942c298d8238ee798c9ca9b" args="(const CorrelationId *correlationIds, size_t numCorrelationIds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void blpapi::AbstractSession::cancel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> *&nbsp;</td>
          <td class="paramname"> <em>correlationIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>numCorrelationIds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For each value specified <code>correlationIds</code> and <code>numCorrelationIds</code> which identifies a current request then cancel that request. Any specified CorrelationId's which do not identify a current request are ignored.</p>
<p>Once this call returns the specified <code>correlationIds</code> will not be seen in any subsequent <a class="el" href="classblpapi_1_1Message.html">Message</a> obtained from a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> by calling next(). However, any <a class="el" href="classblpapi_1_1Message.html">Message</a> currently pointed to by a <a class="el" href="classblpapi_1_1MessageIterator.html">MessageIterator</a> when <a class="el" href="classblpapi_1_1AbstractSession.html#a6351bdef344799c0909cbddede452750">cancel()</a> is called is not affected even if it has one of the specified <code>correlationIds</code>. Also any <a class="el" href="classblpapi_1_1Message.html">Message</a> where a reference has been retained by the application may still contain one of the <code>correlationIds</code>. For these reasons, although technically an application is free to re-use any of the <code>correlationIds</code> as soon as this method returns it is preferable not to aggressively re-use correlation IDs, particularly with an asynchronous <a class="el" href="classblpapi_1_1Session.html">Session</a>. </p>

</div>
</div>
<a class="anchor" id="a7959440c6429554e20dd284e8bc85cc1"></a><!-- doxytag: member="blpapi::Session::generateToken" ref="a7959440c6429554e20dd284e8bc85cc1" args="(const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::generateToken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a token to be used for authorization. If invalid authentication option is specified in session option or there is failure to get authentication information based on authentication option, or if the authentication mode is <code>MANUAL</code> for a user or user and application authentication, then an <a class="el" href="classblpapi_1_1InvalidArgumentException.html">InvalidArgumentException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="a42fee00f84565962540cc803ac7aa741"></a><!-- doxytag: member="blpapi::Session::generateToken" ref="a42fee00f84565962540cc803ac7aa741" args="(const char *userId, const char *ipAddress, const CorrelationId &amp;correlationId=CorrelationId(), EventQueue *eventQueue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::generateToken </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>userId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ipAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classblpapi_1_1EventQueue.html">EventQueue</a> *&nbsp;</td>
          <td class="paramname"> <em>eventQueue</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a token to be used for authorization, using the specified <code>userId</code> and <code>ipAddress</code>. If the authentication mode is not <code>MANUAL</code>, if the <code>userId</code> or <code>ipAddress</code> are not valid or if there's a problem obtaining the authentication information based on the authentication options in <code><a class="el" href="classblpapi_1_1SessionOptions.html">SessionOptions</a></code>, then an <a class="el" href="classblpapi_1_1InvalidArgumentException.html">InvalidArgumentException</a> is thrown. </p>

</div>
</div>
<a class="anchor" id="ac459514f50ddd209be5124d416dd10fe"></a><!-- doxytag: member="blpapi::Session::getService" ref="ac459514f50ddd209be5124d416dd10fe" args="(const char *serviceIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1Service.html">Service</a> blpapi::AbstractSession::getService </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>serviceIdentifier</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Service.html">Service</a> object representing the service identified by the specified <code>serviceIdentifier</code></p>
<p>The <code>serviceIdentifier</code> must contain a fully qualified service name. That is, it must be of the form <code>//&lt;namespace&gt;/&lt;local-name&gt;</code>.</p>
<p>If the service identified by <code>serviceIdentifier</code> is not open or registered already then a <code><a class="el" href="classblpapi_1_1NotFoundException.html">NotFoundException</a></code> is thrown. </p>

</div>
</div>
<a class="anchor" id="ac5d7a27d3ffff9c218a3e02764ee0a86"></a><!-- doxytag: member="blpapi::Session::createUserHandle" ref="ac5d7a27d3ffff9c218a3e02764ee0a86" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">UserHandle</a> blpapi::AbstractSession::createUserHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deprecated: Use <a class="el" href="classblpapi_1_1AbstractSession.html#a3632ffe2a37cccb5ade648a586b55b9d">createIdentity()</a> instead. Return a UserHandle which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="a3632ffe2a37cccb5ade648a586b55b9d"></a><!-- doxytag: member="blpapi::Session::createIdentity" ref="a3632ffe2a37cccb5ade648a586b55b9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classblpapi_1_1Identity.html">Identity</a> blpapi::AbstractSession::createIdentity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <a class="el" href="classblpapi_1_1Identity.html">Identity</a> which is valid but has not been authorized. </p>

</div>
</div>
<a class="anchor" id="a4d7609c1f21e0fea8a7f5af9d7e84f89"></a><!-- doxytag: member="blpapi::Session::generateAuthorizedIdentity" ref="a4d7609c1f21e0fea8a7f5af9d7e84f89" args="(const AuthOptions &amp;authOptions, const CorrelationId &amp;cid=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> blpapi::AbstractSession::generateAuthorizedIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1AuthOptions.html">AuthOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>authOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cid</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates an authorized <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a></code> with the specified <code><a class="el" href="classblpapi_1_1AuthOptions.html">AuthOptions</a></code> and optionally specified <code>cid</code>.</p>
<p>The optionally specified <code>cid</code> is used to track <code><a class="el" href="classblpapi_1_1Event.html">Event</a></code> objects generated as a result of this call. Return the actual <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a></code> object that will identify the messages associated with the generated identity.</p>
<p>One or more <code>AUTHORIZATION_STATUS</code> events, zero or more <code>TOKEN_STATUS</code> events and zero or more <code>SERVICE_STATUS</code> events are generated. If this is an asynchronous <code><a class="el" href="classblpapi_1_1AbstractSession.html">AbstractSession</a></code> then these <code><a class="el" href="classblpapi_1_1Event.html">Event</a></code>s may be processed by the registered <code><a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a></code> before <code><a class="el" href="classblpapi_1_1AbstractSession.html#a4d7609c1f21e0fea8a7f5af9d7e84f89">generateAuthorizedIdentity()</a></code> has returned.</p>
<p>If this is an asynchronous session then an <code><a class="el" href="classblpapi_1_1Event.html">Event</a></code> may be delivered to the registered <code><a class="el" href="classblpapi_1_1EventHandler.html">EventHandler</a></code> before <code><a class="el" href="classblpapi_1_1AbstractSession.html#a4d7609c1f21e0fea8a7f5af9d7e84f89">generateAuthorizedIdentity()</a></code> has returned. </p>

</div>
</div>
<a class="anchor" id="aff20f584012fd465b1839397500954e5"></a><!-- doxytag: member="blpapi::Session::getAuthorizedIdentity" ref="aff20f584012fd465b1839397500954e5" args="(const CorrelationId &amp;correlationId=CorrelationId())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classblpapi_1_1Identity.html">Identity</a> blpapi::AbstractSession::getAuthorizedIdentity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>correlationId</em> = <code><a class="el" href="classblpapi_1_1CorrelationId.html">CorrelationId</a>()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the authorized <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a></code> associated with <code>correlationId</code></p>
<p>A <code><a class="el" href="classblpapi_1_1NotFoundException.html">NotFoundException</a></code> is thrown if there is no <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a></code> associated with <code>correlationId</code>, if the associated <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a></code> is not authorized, or if <code>correlationId</code> is not given and the session <code><a class="el" href="classblpapi_1_1Identity.html">Identity</a></code> is not authorized. </p>

</div>
</div>
<a class="anchor" id="aced40ce5767d5e2d7cb18688a790378e"></a><!-- doxytag: member="blpapi::Session::abstractSessionHandle" ref="aced40ce5767d5e2d7cb18688a790378e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__blpapi__types.html#ga96f76b8c88d6cdc6689fcd59ccf11cf2">blpapi_AbstractSession_t</a>* blpapi::AbstractSession::abstractSessionHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the handle of this abstract session. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a931ba54e37e62f7ee1f6eb96ad62b020"></a><!-- doxytag: member="blpapi::Session::blpapi_eventHandlerAdapter" ref="a931ba54e37e62f7ee1f6eb96ad62b020" args="(blpapi_Event_t *event, blpapi_Session_t *, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blpapi_eventHandlerAdapter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga30bfd6b43ae20d0c8b1baf6f700450c6">blpapi_Event_t</a> *&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__blpapi__types.html#ga54d3f4653b8ff12bc4f9e2a15f1e60d2">blpapi_Session_t</a> *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adapter <code>blpapi_EventHandler_t</code> implementation that dispatches the specified <code>event</code> to a <code><a class="el" href="classblpapi_1_1Session.html">blpapi::Session</a></code> pointed by <code>userData</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="blpapi__session_8h_source.html">blpapi_session.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jul 7 2022 06:44:25 for BLPAPI 3.18.4 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
